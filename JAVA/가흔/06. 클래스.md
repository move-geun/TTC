# 06. 클래스

## 1. 객체 지향 프로그래밍

- 객체들은 독립적으로 존재, 다른 객체와 서로 상호작용하며 수단은 메소드고 다른 객체의 기능을 이용하는 것이 메소드 호출이다

- **집합 관계** : 객체는 하나의 부품이고 하나는 완성품에 해당 (ex: 엔진, 타이어, 핸들 ...)

- **사용 관계** : 객체 간의 상호작용 (ex: 사람과 자동차)

- **상속 관계** : 상위(부모) 객체(-종류)를 기반으로 하위(자식) 객체(-구체적 사물)를 생성(ex: 기계(상위)-자동차(하위))

- ##### **<mark>클래스</mark>**
  
  - 인스턴스 : 클래스로부터 만들어진 객체
  
  - 클래스 설계 > 사용할 객체 생성 > 생성된 객체 이용
  
  - **클래스 선언** (식별자 작성 규칙)
    
    - 하나 이상의 문자로 이루어져야 함
    
    - 첫 글자에는 숫자가 올 수 없음
    
    - `$`, `_` 이외의 특수 문자는 사용할 수 없음
    
    - 자바 키워드는 사용할 수 없음 (ex: int, for)
    
    - `public class 클래스이름 {}`
  
  - **객체 생성**
    
    - `클래스 변수 = new 클래스();`
    
    - 힙 영역에 생성된 후 객체의 번지를 리턴
    
    - 클래스는 하나지만 new 엲산자를 사용한 만큼 객체가 메모리에 생성
  
  - 클래스의 용도
    
    - 라이브러리 클래스 : 다른 클래스에서 이용할 목적
    
    - 실행 클래스 : main() 메소드를 제공
  
  - 구성 멤버
    
    - **필드** : 객체의 공유 데이터, 부품 객체, 상태 정보를 저장하는 곳으로 선언 형태는 변수와 비슷하다. <u>생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.</u> (변수는 실행 종료되면 자동 소멸)
      
      - `int 필드명;`
    
    - **생성자** : new 연산자로 호출되는 특별한 중괄호 {} 블록으로 객체 생성 시 초기화를 담당한다. 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 한다. <u>메소드와 달리 리턴 타입이 없다.</u>
      
      - `ClassName() {}`
    
    - **메소드** : 객체의 동작에 해당하는 {}블록으로 중괄호의 이름은 메소드 이름과 같다. 메소드가 호출되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다. 
      
      - `void methodName() {}`

---

## 2. 필드

- 클래스 {} 블록 어디서든 존재할 수 있지만 생성자와 메소드 중괄호 블록 내부에서는 선언 될 수 없음

- `타입 필드명;` or `타입 필드명 = 초기값;`

- 클래스 내부에서 필드 사용은 단순히 필드 이름으로 가능하지만, <u>클래스 외부에서 사용할 경우 클래스로부터 객체를 생성한 뒤 필드를 사용해야 함</u>
  
  - `Car myCar = new Car();`와 같이 Car 객체를 생성해주어야 함

---

## 3. 생성자

- 모든 클래스에 생성자가 반드시 존재하며, 생성자 선언을 생략했다면 {} 블록 내용이 비어 있는 기본 생성자를 바이트 코드에 자동 추가함

- `[public] 클래스명() {}`

- 명시적 선언 => `클래스( 매개변수선언, ... ) {}`

- 객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 한다면 생성자에서 초기화를 해야함 

- ##### **<mark>생성자 오버로딩</mark>**
  
  - 매개 변수를 달리하는 생성자를 여러 개 선언하는 것
  
  - 단, 매개 변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이 아님
    
    - ```java
      Car(String model, String color) {}
      Car(String color, String model) {}
      ```
  
  - **this()**
    
    - 객체 자신의 참조 `this.필드`
    
    - 생성자 오버로등이 많아질 경우, 한 생성자에만 집중하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출
    
    - 자신의 다른 생성자를 호출하는 코드로 <u>반드시 생성자의 첫 줄에서만 허용</u>
    
    - 호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와 다음 실행문을 진행

---

## 4. 메소드

- 메소드 선언은 <u>선언부(리턴 타입, 메소드 이름, 매개 변수 선언)와 실행블록</u>으로 구성됨

- ##### 메소드 선언
  
  - **리턴 타입**
    
    - 리턴값이 없는 경우에는 변수에 저장할 내용이 없기 때문에 단순히 메소드만 호출
    
    - 리턴값이 있는 경우에는 변수에 저장하고 변수의 타입을 알맞게 지정해주어야 함
    
    - 리턴값이 중요하지 않고, 메소드 실행이 중요할 경우에는 변수 선언없이 메소드 호출 가능
  
  - **메소드 이름**
    
    - 숫자로 시작하면 안되고, `$`와 `_`를 제외한 특수 문자를 사용하지 말아야 함
    
    - 관례적으로 메소드 이름은 소문자로 작성해야 함
    
    - 서로 다른 단어가 혼합된 이름이라면 뒤이어 오는 단어의 첫 글자는 대문자로 작성
  
  - **매개 변수 선언**
    
    - 매개 변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용
    
    - `double res = divide( 10, 20 );`
    
    - 매개 변수의 개수를 모를 경우
      
      - 매개 변수를 배열 타입으로 선언하며 메소드를 호출하기 전에 배열을 생성 : `int sum1(int[] values) { }`
      
      - 매개 변수를 ...를 사용해서 선언하면 자동으로 배열이 생성 : `int sum2(int ... values) { }`

- ##### 리턴문
  
  - **리턴값이 있는 메소드** : 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야 함
  
  - **리턴값이 없는 메소드(void)** : 리턴값이 없는 메소드는 리턴 타입으로 void를 사용하고, 여기서 return문은 메소드 실행을 강제 종료 시키는 역할임
    
    - return문은 메소드를 종료시키기 때문에 추가 실행문이 있을 경우에는 break문을 써야함

- ##### 메소드 호출
  
  - <u>**클래스 내부**</u>의 다른 메소드에서 호출이면 단순한 메소드 이름으로 호출
    
    - `메소드명 (매개값, ...);`
    
    - `타입 변수명 = 메소드명(매개값, ...);`
  
  - <u>**클래스 외부**</u>의 호출에는 객체를 생성한 뒤 참조 변수를 이용해서 호출
    
    - `클래스명 참조변수명 = new 클래스명(매개값, ...);`
    
    - `참조변수명.메소드(매개값, ...);`// 리턴값이 없거나, 있어도 리턴값을 받지 않을 경우
    
    - `타입 변수명 = 참조변수명.메소드(매개값, ...);` //리턴값이 있고, 리턴값을 받고 싶을 경우

- ##### 메소드 오버로딩
  
  - 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
  
  - 매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다
    
    - ```java
      public class Calculator {
          double areaRectangle(double width) {
          return width * width;
          // 정사각형의 넓
      }    
          // 직사각형의 넓
          double areaRectangle(double width, double height) {
          return width * height;
      }
      }
      ```

---

## 5. 인스턴스 멤버와 정적 멤버

- **인스턴스 멤버** : 객체마다 가지고 있는 멤버(필드와 메소드)
  
  - **this**
    
    - 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용

- **정적 멤버** : 클래스에 위치시키고 객체들이 공유하는 멤버
  
  - static 을 사용하여 선언
  
  - `static 타입 필드명;`
  
  - 클래스에 고정된 멤버로 클래스의 로딩이 끝나면 바로 사용 가능
  
  - `클래스.필드;` 로 바로 사용
  
  - 원칙적으로는 클래스 이름으로 접근해야 하지만 객체 참조 변수로도 접근 가능
  
  - **주의점**
    
    - <u>객체가 없어도 실행되기 때문에 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없음</u> => 사용하고 싶다면 개체를 먼저 생성하고 참조 변수로 접근해야 함
    
    - <u>this 키워드 사용 불가</u>
    
    - main 메소드도 정적 메소드이며 인스턴스 메소드를 바로 사용할 수 없음

- 객체마다 가지고 있어야 할 데이터라면 인스턴스 필드, 공용 데이터라면 정적 필드로 선언

- **<mark>싱글톤</mark>**
  
  - 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우, 하나만 생성된 객체
  
  - 외부에서 생성자 호출을 막기 위해 private를 붙여줘야 함
  
  - 내부에서는 new 연산자로 생성자 호출 가능
  
  - `private static 클래스명 singleton = new 클래스();`
  
  - 외부에서 객체를 얻는 방법은 `getInstance()` 메소드 호출
    
    - `클래스 변수 = 클래스.getInstance();`

- **final 필드**
  
  - 초기값이 저장되면 프로그램 실행 도중 수정할 수 없는 최종적인 값
  
  - `final 타입 필드명 [=초기값];`
  
  - 필드 선언 시에 초기값 선언 혹은 생성자에서 주는 방법

- 상수
  
  - 불변의 값을 저장하는 필드
  
  - 객체마다 저장할 필요가 없는 공용성을 띄며 여러 가지 값으로 초기화 될 수 없음
    
    - 상수는 static이면서 final이어야 함
  
  - <u>final 필드는 객체마다 저장되고 생성자의 매개값을 통해 여러 가지 값을 가질 수 있기 때문에 상수가 아님</u>
  
  - `static final 타입 상수명 = 초기값;`
  
  - 상수 이름은 모두 대문자로 작성하는 것이 관례

---

# 6. 패키지와 접근 제한자

- 패키지 선언 : `package 상위패키지.하위패키지;`

- 클래스만 따로 복사해서 다른 곳으로 이동하면 클래스를 사용할 수 없음

- 클래스를 이동해야 하면 패키지 전체를 이동

- **패키지 이름**
  
  - 숫자로 시작해서는 안되고, `_`, `$` 를 제외한 특수 문자를 사용해서는 안 됨
  
  - java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용해서는 안 도미
  
  - 모두 소문자로 작성하는 것이 관례

- import문
  
  - 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속되어 있을때 사용
  
  - `import 상위패키지.하위패키지.클래스명;`
  
  - `import 상위패키지.하위패키지.*;`
  
  - 패키지 선언과 클래스 선언 사이에 작성
  
  - 상위 패키지를 import 했다고 해서 하위 패키지까지 import 되는 것이 아니기 때문에 두 패키지 모두 각각 import 해줘야 함
  
  - <u>서로 다른 패키지에 동일한 클래스 이름이 존재할 때, 정확하게 패키지가 포함된 클래스 전체 이름을 기술해야 함</u>

- **<mark>접근 제한자</mark>**
  
  - **<mark>public 접근 제한자</mark>** : 외부 클래스가 자유롭게 사용
    
    - `public class 클래스명 {}`
  
  - **protected 접근 제한자** : 같은 패키지 또는 자식 클래스에서 사용
  
  - **private 접근 제한자** : 외부에서 사용 불가
  
  - **<mark>default 접근 제한자</mark>** : 같은 패키지에 소속된 클래스에서만 사용
    
    - 클래스 선언시 public을 생략했다면 default 접근 제한을 가짐
    
    - `class 클래스명 {}`

- **생성자의 접근 제한**
  
  - **public 접근 제한** : 아무런 제한 없이 생성자 호출 가능
  
  - **protected 접근 제한** : 같은 패키지에 속하는 클래스에서 생성자를 호출, 다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 생성자 호출 가능
  
  - **default 접근 제한** : 같은 패키지에서는 제한 없으나 다른 패키지에서는 생성자를 호출 할 수 없음
  
  - **private 접근 제한** : 오로지 클래스 내부에서만 생성자를 호출하고 객체를 생성할 수 있음

- **필드와 메소드의 접근 제한**
  
  - **public 접근 제한** : 제한 없이 필드와 메소드를 사용
  
  - **protected 접근 제한** : 같은 패키지에 속하는 클래스에서 필드와 메소드를 사용, 다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 사용 가능
  
  - **default 접근 제한** : 접근 제한자를 생략하면 default 접근 제한을 가짐, 같은 패키지에서만 제한 없이 사용 가능
  
  - **private 접근 제한** : 오직 클래스 내부에서만 사용 가능

- Getter와 Setter 메소드
  
  - 객체 지향 프로그래밍에서는 무결성이 깨질 수 있기 때문에, 객체의 필드를 객체 외부에서 직접적으로 접근하는 것을 막음
  
  - 그러므로 <u>메소드를 통해서 필드를 변경해야 함</u>
  
  - **<mark>Setter</mark>** : 매개값을 검증해서 유효한 값만 객체의 필드로 저장
  
  - **<mark>Getter </mark>**: 필드값을 가공한 후 외부로 전달
  
  - 클래스 선언 시 필드를 private로 선언해서 보호하고, 메소드를 이용해서 필드값을 안전하게 변경/사용 하는 것이 좋음
    
    - 외부에서 필드값을 읽을 수만 있고 변경하지 못하도록 하려면 (읽기 전용) `Getter 메소드`
    
    - 아니면 `Setter 메소드`가 private 접근 제한을 갖도록 선언
    
    - `get+필드이름(첫글자는 대문자)`
    
    - `set+필드이름(첫글자는 대문자)`
    
    - 필드 타입이 boolean이 경우에는 Getter 메소드가 `is+필드이름(첫글자는 대문자)`  
