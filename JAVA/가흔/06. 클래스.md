# 06. 클래스

## 1. 객체 지향 프로그래밍

- 객체들은 독립적으로 존재, 다른 객체와 서로 상호작용하며 수단은 메소드고 다른 객체의 기능을 이용하는 것이 메소드 호출이다

- **집합 관계** : 객체는 하나의 부품이고 하나는 완성품에 해당 (ex: 엔진, 타이어, 핸들 ...)

- **사용 관계** : 객체 간의 상호작용 (ex: 사람과 자동차)

- **상속 관계** : 상위(부모) 객체(-종류)를 기반으로 하위(자식) 객체(-구체적 사물)를 생성(ex: 기계(상위)-자동차(하위))

- ##### **<mark>클래스</mark>**
  
  - 인스턴스 : 클래스로부터 만들어진 객체
  
  - 클래스 설계 > 사용할 객체 생성 > 생성된 객체 이용
  
  - **클래스 선언** (식별자 작성 규칙)
    
    - 하나 이상의 문자로 이루어져야 함
    
    - 첫 글자에는 숫자가 올 수 없음
    
    - `$`, `_` 이외의 특수 문자는 사용할 수 없음
    
    - 자바 키워드는 사용할 수 없음 (ex: int, for)
    
    - `public class 클래스이름 {}`
  
  - **객체 생성**
    
    - `클래스 변수 = new 클래스();`
    
    - 힙 영역에 생성된 후 객체의 번지를 리턴
    
    - 클래스는 하나지만 new 엲산자를 사용한 만큼 객체가 메모리에 생성
  
  - 클래스의 용도
    
    - 라이브러리 클래스 : 다른 클래스에서 이용할 목적
    
    - 실행 클래스 : main() 메소드를 제공
  
  - 구성 멤버
    
    - **필드** : 객체의 공유 데이터, 부품 객체, 상태 정보를 저장하는 곳으로 선언 형태는 변수와 비슷하다. <u>생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.</u> (변수는 실행 종료되면 자동 소멸)
      
      - `int 필드명;`
    
    - **생성자** : new 연산자로 호출되는 특별한 중괄호 {} 블록으로 객체 생성 시 초기화를 담당한다. 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 한다. <u>메소드와 달리 리턴 타입이 없다.</u>
      
      - `ClassName() {}`
    
    - **메소드** : 객체의 동작에 해당하는 {}블록으로 중괄호의 이름은 메소드 이름과 같다. 메소드가 호출되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다. 
      
      - `void methodName() {}`

---

## 2. 필드

- 클래스 {} 블록 어디서든 존재할 수 있지만 생성자와 메소드 중괄호 블록 내부에서는 선언 될 수 없음

- `타입 필드명;` or `타입 필드명 = 초기값;`

- 클래스 내부에서 필드 사용은 단순히 필드 이름으로 가능하지만, <u>클래스 외부에서 사용할 경우 클래스로부터 객체를 생성한 뒤 필드를 사용해야 함</u>
  
  - `Car myCar = new Car();`와 같이 Car 객체를 생성해주어야 함

---

## 3. 생성자

- 모든 클래스에 생성자가 반드시 존재하며, 생성자 선언을 생략했다면 {} 블록 내용이 비어 있는 기본 생성자를 바이트 코드에 자동 추가함

- `[public] 클래스명() {}`

- 명시적 선언 => `클래스( 매개변수선언, ... ) {}`

- 객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 한다면 생성자에서 초기화를 해야함 

- ##### **<mark>생성자 오버로딩</mark>**
  
  - 매개 변수를 달리하는 생성자를 여러 개 선언하는 것
  
  - 단, 매개 변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이 아님
    
    - ```java
      Car(String model, String color) {}
      Car(String color, String model) {}
      ```
  
  - **this()**
    
    - 객체 자신의 참조 `this.필드`
    
    - 생성자 오버로등이 많아질 경우, 한 생성자에만 집중하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출
    
    - 자신의 다른 생성자를 호출하는 코드로 <u>반드시 생성자의 첫 줄에서만 허용</u>
    
    - 호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와 다음 실행문을 진행

---
